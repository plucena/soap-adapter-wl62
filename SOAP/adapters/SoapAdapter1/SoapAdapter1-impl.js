
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Generated code - Do not edit																					 //
//																												 //
// This is a SOAP adapter that was auto-generated by Worklight for invocation of specific SOAP-based services.   //
// The adapter may invoke more than one service as long as they are all from the same enpdpoint (server host).   //
// Each adapter procedure matches a single operation for the same endpoint server and accepts:                   //
//   params  - Serialized JSON representation of the XML-based SOAP body to be sent to the service               //
//   headers - Custom HTTP headers to be specified when invoking the remote service. It is a JSON object with    //
//             the headers names and values. E.g. { 'name1' : 'value1', 'name2' : 'value2' }                     //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function LoginWS_login(params, headers){
	var soapEnvNS = '';
    // The value of 'soapEnvNS' was set based on the version of the SOAP to be used (i.e. 1.1 or 1.2).
    soapEnvNS = 'http://schemas.xmlsoap.org/soap/envelope/';

	// The following mappings object was autogenerated from the XML schema of the input message to the service.
    // It is being used to support a params JSON when invoking this procedure that don't specify the namespace
    // prefix nor specifying whether a property is attribute or not.
    // 
    // The 'roots' object has the list of message parts within the invocation SOAP message. Each entry has a
    // mapping between the root element name and its namespace prefix and type.
    // Each root object may define 'nsPrefix' and 'type'. Both are optional - If there is no need for a NS prefix
    // then the 'nsPrefix' should not be specified. If the element is a simple type then the 'type' should not be
    // specified.
    //
    // The 'types' object has a list of types each defining the children of the type and the definition of each
    // child. If the child is a complext type, the 'type' property has a reference to the child type definition.
    // Each child object may define:
    // 'nsPrefix' (optional) - Holds the namespace prefix to be attached to the element. If there is no need for 
    //   a NS prefix then the 'nsPrefix' should not be specified. 
    // 'type' (optional) - If the element is a simple type then the 'type' should not be specified. If it is an 
    //   attribute then 'type' should have the value of '@'. Otherwise the value of 'type' is a reference to the 
    //   type definition within the 'types' object.
    var mappings = {
		roots: {
			'login': { nsPrefix: 'tns', type: 'tns:login' }				
		},
		
		types: {
			'tns:login': {
				children: {
					'usuario': {  }	
				}
			}
		}
	};
    var namespaces = 'xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:tns="http://ws.unasp.com/" xmlns:wsp1_2="http://schemas.xmlsoap.org/ws/2004/09/policy" xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" ';
    var request = buildBody(params, namespaces, mappings, soapEnvNS);
    var soapAction = '';
    return invokeWebService(request, headers, soapAction);
}


	
function buildBody(params, namespaces, mappings, soapEnvNS){
    var body =
        '<soap:Envelope xmlns:soap="' + soapEnvNS + '">\n' +
        '<soap:Body>\n';
	
	var fixedParams = {};
	for (var paramName in params) {
		if (mappings['roots'][paramName]) { //There is mapping for this param
    		var root = mappings['roots'][paramName];
    		var name = paramName;
    		if (root['nsPrefix'])
    			name = root['nsPrefix'] + ':' + paramName;
    		fixedParams[name] = handleMappings(params[paramName], root['type'], mappings['types']); 
		}
		else {
			fixedParams[paramName] = params[paramName];
		}
	}

    body = jsonToXml(fixedParams, body, namespaces);
		
    body += 
        '</soap:Body>\n' +
        '</soap:Envelope>\n';
    return body;
}

function handleMappings(jsonObj, type, mappings) {
	var fixedObj = {};
	var typeMap = mappings[type]['children']; //Get the object that defines the mappings for the specific type
	for (var key in jsonObj) {
		if (typeMap[key]) { // Mapping exist
			var childName = key;
			if (typeMap[key]['nsPrefix'])
				childName = typeMap[key]['nsPrefix'] + ':' + key;
			
			if (!typeMap[key]['type']) //Simple type element
				fixedObj[childName] = jsonObj[key];
			else if (typeof jsonObj[key] === 'object' && jsonObj[key].length != undefined) { //Array of complex type elements
				fixedObj[childName] = [];
				for (var i=0; i<jsonObj[key].length; i++)
					fixedObj[childName][i] = handleMappings(jsonObj[key][i], typeMap[key]['type'], mappings);
			}
			else if (typeof jsonObj[key] === 'object') //Complex type element
				fixedObj[childName] = handleMappings(jsonObj[key], typeMap[key]['type'], mappings);
			else if (typeMap[key]['type'] == '@') //Attribute
				fixedObj['@' + childName] = jsonObj[key];
		}
		else { // No mapping
			fixedObj[key] = jsonObj[key];
		}
    }
	
	return fixedObj;
}

function getAttributes(jsonObj) {
	var attrStr = '';
	for(var attr in jsonObj) {
		if (attr.charAt(0) == '@') {
		    var val = jsonObj[attr];
			attrStr += ' ' + attr.substring(1);
			attrStr += '="' + xmlEscape(val) + '"';
		}
	}
	return attrStr;
}

function jsonToXml(jsonObj, xmlStr, namespaces) {
	var toAppend = '';
	for(var attr in jsonObj) {
		if (attr.charAt(0) != '@') {
		    var val = jsonObj[attr];
			if (typeof val  === 'object'  &&  val.length != undefined) {
				for(var i=0; i<val.length; i++) {
					toAppend += "<" + attr + getAttributes(val[i]);
					if (namespaces != null)
						toAppend += ' ' + namespaces;
					toAppend += ">\n";
					toAppend = jsonToXml(val[i], toAppend);
					toAppend += "</" + attr + ">\n";
				}
			}
			else {
				toAppend += "<" + attr;
			    if (typeof val  === 'object') {
					toAppend += getAttributes(val);
					if (namespaces != null)
						toAppend += ' ' + namespaces;
					toAppend += ">\n";
					toAppend = jsonToXml(val, toAppend);
				}
				else {
					toAppend += ">" + xmlEscape(val);
				}
				toAppend += "</" + attr + ">\n";
			}
		}
	}
	return xmlStr += toAppend;
}


function invokeWebService(body, headers, soapAction){
    var input = {
        method : 'post',
        returnedContentType : 'xml',
        path : '/WS/LoginWS',
        body: {
            content : body.toString(),
            contentType : 'text/xml; charset=utf-8'
        }
    };
    
    //Adding custom HTTP headers if they were provided as parameter to the procedure call
    //Always add header for SOAP action 
    headers = headers || {};
    if (soapAction != 'null')
    	headers.SOAPAction = soapAction;
    input['headers'] = headers;
        
    return WL.Server.invokeHttp(input);
}

function xmlEscape(obj) {
    if(typeof obj !== 'string') {
    	return obj;
    }
    return obj.replace(/&/g, '&amp;')
           .replace(/"/g, '&quot;')
           .replace(/'/g, '&apos;')
           .replace(/</g, '&lt;')
           .replace(/>/g, '&gt;');
}

